public class ExploreThenExploit extends NonstationaryDuelingAlgorithm {
	
	private final StationaryDuelingAlgorithm alg;		// used Dueling algorithm
	private final int tildeT;							// number of time steps for exploration using alg
	private final int w;								// window length
	private final double b;								// threshold for changepoint detection
	private int t;										// current timestep reseted at detected changepoints
	private int firstArm;								// last first arm played
	private int secondArm;								// last second arm played
	private Window[][] windows;							// detection windows for each pair of arms
	private final double error;							// DGIM error to be used
	private int lastArm = 0;							// lastArm used during exploitation phase
	private final String nameSuffix;
	private final boolean heuristicParameters;
	
	public ExploreThenExploit(int K, int tildeT, int w, double b, StationaryDuelingAlgorithm alg, double error, double pmin) {
		super(K);
		this.alg = alg;
		this.tildeT = tildeT;
		this.w = w;
		this.b = b;
		this.error = error;
		nameSuffix = "";
		this.heuristicParameters = false;
	}
	
	// sets parameters as in Corollary 4.16 or Corollary 4.17 (if alternative is true) for alg being Beat the Winner
	public ExploreThenExploit(int K, int T, StationaryDuelingAlgorithm alg, double error, double delta, double pmin, boolean alternative, boolean heuristicParameters) {
		super(K);
		this.heuristicParameters = heuristicParameters;
		this.alg = alg;
		double errorTerm = heuristicParameters ? 1.0 : 1.0+2.0*error+5.0*error*error;
		double pmin2 = Math.pow(2.0*pmin-1.0, 2);
		double wDenominator =  heuristicParameters ? Math.pow(delta, 2) : Math.pow((1.0+error)*delta-8.0*error, 2);
		this.error = error;
		if (alternative) {
			this.tildeT = (int) Math.sqrt(T);
			double x = Math.exp(-(Math.sqrt(Math.sqrt(T))-K+1.0)*pmin2) / (1.0-Math.exp(-pmin2));
			int preW = (int) Math.ceil(8.0 * errorTerm * Math.log(2.0 * T / x) / wDenominator);
			this.w = preW % 2 == 0 ? preW : preW+1;
			this.b = Math.sqrt(errorTerm * w / 2.0 * Math.log(2.0 * T / x)) + (heuristicParameters ? 0.0 : 2.0*w*error);
			nameSuffix = "a";
		} else {
			this.tildeT = (int) Math.pow(Math.log(T / ((1-Math.exp(-pmin2)) * Math.log(T))) / pmin2 + K-1.0, 2);
			int preW = (int) Math.ceil(errorTerm * (16.0 * Math.log(T) + 6.0) / wDenominator);
			this.w = preW % 2 == 0 ? preW : preW+1;
			this.b = Math.sqrt(errorTerm * w * (Math.log(T) + 3.0/8.0)) + (heuristicParameters ? 0.0 : 2.0*w*error);
			nameSuffix = "";
		}
	}

	@Override
	public void initialize() {
		alg.initialize();
		t = 1;
		resets.clear();
		
		// initializes DGIM instances if error is greater 0
		if (error == 0) {
			windows = new DoubleQueue[K][K];
			for (int i = 0; i < K; i++) {
				for (int j = i+1; j < K; j++)
					windows[i][j] = new DoubleQueue(w);
			}
		} else {
			windows = new DGIM[K][K];
			for (int i = 0; i < K; i++) {
				for (int j = i+1; j < K; j++)
					windows[i][j] = new DGIM(w, error);
			}
		}
	}

	@Override
	public int[] getPair() {
		// returns the pair played by the dueling algorithm if in exploration phase
		if (t <= tildeT)
			return alg.getPair();
		else {
			// simultaneously exploits and checks for changepoints by using the suspected condorcet winner of the dueling algorithm
			firstArm = alg.getSuspectedCondorcetWinner();
			
			// selects the next second arm different to the suspected condorcet winner
			secondArm = t == tildeT+1 ? 0 : (lastArm+1) % K;
			if (secondArm == firstArm)
				secondArm = (secondArm+1) % K;
			lastArm = secondArm;
			
			// makes sure that the pair is ordered
			if (secondArm < firstArm) {
				firstArm = secondArm;
				secondArm = alg.getSuspectedCondorcetWinner();
			}
			
			int[] pair = {firstArm, secondArm};
			return pair;
		}
	}

	@Override
	public void update(boolean firstWon) {
		// updates the dueling algorithm during exploration phase
		if (t <= tildeT) {
			alg.update(firstWon);
			t++;
		} else {
			t++;
			Window window = windows[firstArm][secondArm];
			window.push(firstWon);
			// checks if the the detection window is filled and the threshold exceeded
			if (window.isFilled() && Math.abs(window.getFirstSum() - window.getSecondSum()) > b) {
				// adds the reset to the histogram
				int reset = resets.size() == 0 ? t-1 : t-1 + resets.get(resets.size()-1);
				resets.add(reset);
				hist.add(reset);
				
				// initializes the algorithm and the windows
				t=1;
				alg.initialize();
				for (int i = 0; i < K-1; i++) {
					for (int j = i+1; j < K; j++)
						windows[i][j].clear();
				}
			}
		}
	}

	@Override
	public String toString() {
		return "EtE" + nameSuffix + " " + "E" + (heuristicParameters ? "H" : "") + String.valueOf(error).replace(".", ",") + " " + alg;
	}
	
	@Override
	public void printParameters() {
		System.out.println("tildeT: " + tildeT);
		System.out.println("w: " + w);
		System.out.println("b: " + b);
	}

	@Override
	public int getWindowSpan() {
		return (w-1)*(K-1)+1;
	}

}